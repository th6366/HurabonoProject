/* 
 * Godmar Back 
 * University of Utah, Computer Systems Lab, 1995 
 * 
 * my favorite tetris in Java 
 */ 
  
import java.awt.*; 
import java.io.*; 

class Square { 
  
 int x, y, c;      //x좌표, y좌표, 색깔

 Square(int x, int y, int c) { 
  this.x = x; 
  this.y = y; 
  this.c = c; 
 }

 int X() { return x; } 
 int Y() { return y; } 
 int Color() { return c; } 

boolean InBounds() {     // 게임영역 
   return (x >= 0 && x < Tetris.cols && y >= 0 && y < Tetris.rows+4); 
 } 

boolean IsEqual(Square s) { 
   return x == s.x && y == s.y && c == s.c; 
 } 
  
} //  위로 

public class Tetris extends java.applet.Applet implements Runnable {

 static   int sqlength;          // square 사각형 길이 
 static final int xoffset = 200; // 왼쪽부터 거리 
 static   int cols;              // columns 
 static   int rows;              // rows

 int  f[][]; 
 int  of[][];

 int  what;                          // 현재조각의 타입 
 Square  curpiece[] = new Square[4]; // 현재조각

 boolean  lost; 
 boolean  neednewpiece;

 Thread  killme = null;

 Color  colors[]; 
 int  curval, score=0;

 int  level;    // 현재의 게임단계 
 int  pieces;   // 떨어진 조각의 수

 String   highscorehost; 
 short    highscoreport;

 boolean  blackwhite;         // 흑백 
 boolean  suspended = false; 
 boolean  justupdating = false;

//  위로
  
// 조각의 이동 
private boolean movepiece(Square from[], Square to[]) {
      outerlabel:

     for (int i=0; i<to.length; i++) {

         if (!to[i].InBounds()) { return false; }

         if (f[to[i].X()][to[i].Y()] != 0) {

             for (int j=0; j<from.length; j++)

                  if(to[i].IsEqual(from[j])) { 
                       continue outerlabel; 
                  } 
                  return false; // 이동 불가 
             } 
         }

         // blank old piece 
         for (int i=0; i<from.length; i++)

             if(from[i].InBounds()) {

                  f[from[i].X()][from[i].Y()] = 0; 
             }

         // 새로운 조각 표시 
         for (int i=0; i<to.length; i++) 
             f[to[i].X()][to[i].Y()] = to[i].Color();

         return true; 
  
 } //  위로 

// 새로운 조각 
private void newpiece() { 
  
     Square  old[] = new Square[4]; 
     old[0] = old[1] = old[2] = old[3] = new Square(-1, -1, 0);

     int m = cols/2; 
     what = (int) (Math.random()*7);

     switch(what) {

         case 0: 
          // XXXX 
          curval = 100; 
          curpiece[0] = new Square(m-1, rows-1, 1); 
          curpiece[1] = new Square(m-2, rows-1, 1); 
          curpiece[2] = new Square(m,   rows-1, 1); 
          curpiece[3] = new Square(m+1, rows-1, 1); 
          break;

         case 1: 
          //  X 
          // XXX 
          curval = 120; 
          curpiece[0] = new Square(m  , rows-2, 5); 
          curpiece[1] = new Square(m  , rows-1, 5); 
          curpiece[2] = new Square(m-1, rows-2, 5); 
          curpiece[3] = new Square(m+1, rows-2, 5); 
          break;

        case 2: 
          // XX 
          //  XX 
          curval = 180; 
          curpiece[0] = new Square(m  , rows-2, 2); 
          curpiece[1] = new Square(m-1, rows-1, 2); 
          curpiece[2] = new Square(m  , rows-1, 2); 
          curpiece[3] = new Square(m+1, rows-2, 2); 
          break;

         case 3: 
          //  XX 
          // XX 
          curval = 180; 
          curpiece[0] = new Square(m  , rows-2, 7); 
          curpiece[1] = new Square(m+1, rows-1, 7); 
          curpiece[2] = new Square(m  , rows-1, 7); 
          curpiece[3] = new Square(m-1, rows-2, 7); 
          break;

         case 4: 
          //  XX 
          //  XX 
          curval = 100; 
          curpiece[0] = new Square(m-1, rows-1, 3); 
          curpiece[1] = new Square(m  , rows-1, 3); 
          curpiece[2] = new Square(m-1, rows-2, 3); 
          curpiece[3] = new Square(m  , rows-2, 3); 
          break;

         case 5: 
          //  XXX 
          //    X 
          curval = 120; 
          curpiece[0] = new Square(m  , rows-1, 6); 
          curpiece[1] = new Square(m-1, rows-1, 6); 
          curpiece[2] = new Square(m+1, rows-1, 6); 
          curpiece[3] = new Square(m+1, rows-2, 6); 
          break;

         case 6: 
          //  XXX 
          //  X 
          curval = 120; 
          curpiece[0] = new Square(m  , rows-1, 4); 
          curpiece[1] = new Square(m+1, rows-1, 4); 
          curpiece[2] = new Square(m-1, rows-1, 4); 
          curpiece[3] = new Square(m-1, rows-2, 4); 
          break; 
     } 
     lost = !movepiece(old, curpiece); 
  
 } //  위로

// run()으로

// 현재조각의 이동 
private synchronized boolean movecurpiece(int byx, int byy, boolean rotate) { 
  
     Square newpos[] = new Square[4];
     for(int i=0; i<4; i++) {

         if(rotate) {

              int dx = curpiece[i].X() - curpiece[0].X(); 
              int dy = curpiece[i].Y() - curpiece[0].Y(); 
  
              newpos[i] = new Square( curpiece[0].X() - dy, 
                  curpiece[0].Y() + dx, 
                  curpiece[i].Color());

         } else

              newpos[i] = new Square( curpiece[i].X() + byx, 
              curpiece[i].Y() + byy, 
              curpiece[i].Color());

         }

         if (!movepiece(curpiece, newpos)) return false;

         curpiece = newpos; 
         return true; 
  
    } //  위로

// keyDown()으로

// 채워진 행 제거 
private void removelines() { 
  
      outerlabel:
      for (int j=0; j<rows; j++) {

         // j번째 라인 확인 
         for (int i=0; i<cols; i++) 
             if (f[i][j] == 0) 
                  continue outerlabel;

         // j번째 라인제거 
         for (int k=j; k<rows-1; k++) 
             for (int i=0; i<cols; i++) 
                 f[i][k] = f[i][k+1];

         // j번째 라인 재확인 
         j--; 
       } 
  }
