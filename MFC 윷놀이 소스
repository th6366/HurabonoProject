// KBoardDlg.cpp : implementation file//#include "stdafx.h"#include "KBoard.h"#include "KBoardDlg.h"#ifdef _DEBUG#define new DEBUG_NEW#undef THIS_FILEstatic char THIS_FILE[] = __FILE__;#endif#define X1 20#define Y1 20#define StartX2 320#define StartY2 320#define DOLX 500#define DOLY 30#define R 30#define NUMX 10#define NUMY 5#define PERSON 0#define COM 1#define START 0struct DOL { int x1,y1,x2,y2,which,num; // which - 사람돌인지 컴퓨터돌인지 num - 첫번째돌인지 두번째돌인지};int Step, step2, PersonDOL, ComDOL ,Y[4], CY2[4], pae, Cpae, Move_Count, CMove_Count, whichturn,mode,PanDOLX,PanDOLY,    HfirstDOLx, HfirstDOLy, HsecondDOLx, HsecondDOLy, CfirstDOLx, CfirstDOLy,  CsecondDOLx, CsecondDOLy, COM1or2, PERSON1or2, Run=1, WhoWin, Shade, rx,ry, which;CString pae_Str, Cpae_Str;struct DOL MDOL[2];BOOL Pone, Cone, HFirstDOLIn, HSecondDOLIn, CFirstDOLIn, CSecondDOLIn, HDOUBLE, CDOUBLE, ONEMORE, CONEMORE, HfirstDOLC, HsecondDOLC, CfirstDOLC, CsecondDOLC, CAPTURE,AGAIN, PaintCALL;CFont m_Font, *OldFont, Edit_Font, *OldEditFont;/////////////////////////////////////////////////////////////////////////////// CKBoardDlg dialogCKBoardDlg::CKBoardDlg(CWnd* pParent /*=NULL*/) : CDialog(CKBoardDlg::IDD, pParent){ //{{AFX_DATA_INIT(CKBoardDlg) m_notice = _T(""); //}}AFX_DATA_INIT // Note that LoadIcon does not require a subsequent DestroyIcon in Win32 m_hIcon = AfxGetApp()->LoadIcon(IDR_MAINFRAME); AfxInitRichEdit();}void CKBoardDlg::DoDataExchange(CDataExchange* pDX){ CDialog::DoDataExchange(pDX); //{{AFX_DATA_MAP(CKBoardDlg) DDX_Text(pDX, IDC_NOTICE, m_notice); //}}AFX_DATA_MAP}BEGIN_MESSAGE_MAP(CKBoardDlg, CDialog) //{{AFX_MSG_MAP(CKBoardDlg) ON_WM_PAINT() ON_WM_QUERYDRAGICON() ON_BN_CLICKED(IDC_GO, OnGo) ON_BN_CLICKED(IDC_DOL1, OnDol1) ON_BN_CLICKED(IDC_DOL2, OnDol2) //}}AFX_MSG_MAPEND_MESSAGE_MAP()/////////////////////////////////////////////////////////////////////////////// CKBoardDlg message handlersvoid CKBoardDlg::DrawY(){ // 윷그리기 CClientDC dc(this); if (whichturn==PERSON) { for (int i=0;i<4;i++) {    CBrush b,*pOB;  switch(Y[i]) {  case 0 : b.CreateSolidBrush(RGB(0,0,0)); break;  case 1 : b.CreateSolidBrush(RGB(255,255,255)); break;  }  pOB = (CBrush *)dc.SelectObject(&b);  int x,y;  x=DOLX-50+i*25; y=DOLY+80;  dc.Rectangle(x,y,x+20,y+50);  dc.SelectObject(pOB); } } else { for (int i=0;i<4;i++) {    CBrush cb, *cOB;  switch(CY2[i]) {  case 0 : cb.CreateSolidBrush(RGB(0,0,0)); break;  case 1 : cb.CreateSolidBrush(RGB(255,255,255)); break;  }  cOB = (CBrush *)dc.SelectObject(&cb);  int x,y;  x=DOLX-50+i*25; y=DOLY+80;  dc.Rectangle(x,y,x+20,y+50);  dc.SelectObject(cOB); } }}void CKBoardDlg::EraseDOL(){ CClientDC dc(this); CBrush b,*pOB; b.CreateSolidBrush(RGB(255,255,255)); pOB = (CBrush *)dc.SelectObject(&b); int x,y;    if (whichturn==PERSON) {  if (PERSON1or2==1) { switch (HfirstDOLy) { case 0 : x = StartX2; y = StartY2-HfirstDOLx*Step; break; case 1 : x = StartX2-HfirstDOLx*Step; y = Y1; break; case 2 : x = X1; y = Y1+HfirstDOLx*Step; break; case 3 : x = X1+HfirstDOLx*Step; y = StartY2; break; case 4 : x = StartX2-HfirstDOLx*step2; y=Y1+HfirstDOLx*step2; break;  case 5 : x = X1+HfirstDOLx*step2; y=Y1+HfirstDOLx*step2; break; }    }  else { switch (HsecondDOLy) { case 0 : x = StartX2; y = StartY2-HsecondDOLx*Step; break; case 1 : x = StartX2-HsecondDOLx*Step; y = Y1; break; case 2 : x = X1; y = Y1+HsecondDOLx*Step; break; case 3 : x = X1+HsecondDOLx*Step; y = StartY2; break; case 4 : x = StartX2-HsecondDOLx*step2; y=Y1+HsecondDOLx*step2; break;  case 5 : x = X1+HsecondDOLx*step2; y=Y1+HsecondDOLx*step2; break; }    } }  else if (whichturn==COM) {  if (COM1or2==1) { // 첫번째 돌 움직일 차례면  switch (CfirstDOLy) { case 0 : x = StartX2; y = StartY2-CfirstDOLx*Step; break; case 1 : x = StartX2-CfirstDOLx*Step; y = Y1; break; case 2 : x = X1; y = Y1+CfirstDOLx*Step; break; case 3 : x = X1+CfirstDOLx*Step; y = StartY2; break; case 4 : x = StartX2-CfirstDOLx*step2; y=Y1+CfirstDOLx*step2; break; case 5 : x = X1+CfirstDOLx*step2; y=Y1+CfirstDOLx*step2; break; }    }  else {  switch (CsecondDOLy) {  case 0 : x = StartX2; y = StartY2-CsecondDOLx*Step; break;  case 1 : x = StartX2-CsecondDOLx*Step; y = Y1; break;  case 2 : x = X1; y = Y1+CsecondDOLx*Step; break;  case 3 : x = X1+CsecondDOLx*Step; y = StartY2; break;  case 4 : x = StartX2-CsecondDOLx*step2; y=Y1+CsecondDOLx*step2; break;  case 5 : x = X1+CsecondDOLx*step2; y=Y1+CsecondDOLx*step2; break;  }  } } dc.Ellipse(x,y,x+R,y+R); dc.SelectObject(pOB);}int CKBoardDlg::CaculateX(BOOL HumanOrCom){ int xx,yy; switch (HumanOrCom) {    case PERSON : if (which==1) {            switch (HfirstDOLy) {      case 0 : if (HfirstDOLx==0) xx=DOLX; else { xx = StartX2; yy = StartY2-HfirstDOLx*Step; } break; // 아래에서 위쪽으로      case 1 : xx = StartX2-HfirstDOLx*Step; yy = Y1; break; // 오른쪽에서 왼쪽으로      case 2 : xx = X1; yy = Y1+HfirstDOLx*Step; break; // 위에서 아래로      case 3 : xx = X1+HfirstDOLx*Step; yy = StartY2; break; // 왼쪽에서 오른쪽으로      case 4 : xx = StartX2-HfirstDOLx*step2; yy = Y1+HfirstDOLx*step2; break; // 오른쪽위대각선에서 왼쪽아래 대각선으로      case 5 : xx = X1+HfirstDOLx*step2; yy = Y1+HfirstDOLx*step2; break; // 왼쪽위 대각선에서 오른쪽아래 대각선으로                  }      }   if (which==2) {   switch (HsecondDOLy) {   case 0 : if (HsecondDOLx==0) xx=DOLX+R+5; else { xx = StartX2; yy = StartY2-HsecondDOLx*Step; } break; // 아래에서 위쪽으로      case 1 : xx = StartX2-HsecondDOLx*Step; yy = Y1; break; // 오른쪽에서 왼쪽으로      case 2 : xx = X1; yy = Y1+HsecondDOLx*Step; break; // 위에서 아래로      case 3 : xx = X1+HsecondDOLx*Step; yy = StartY2; break; // 왼쪽에서 오른쪽으로      case 4 : xx = StartX2-HsecondDOLx*step2; yy = Y1+HsecondDOLx*step2; break; // 오른쪽위대각선에서 왼쪽아래 대각선으로      case 5 : xx = X1+HsecondDOLx*step2; yy = Y1+HsecondDOLx*step2; break; // 왼쪽위 대각선에서 오른쪽아래 대각선으로                  }      }                  break;                   case COM : if (which==1) {            switch (CfirstDOLy) {      case 0 : if (CfirstDOLx==0) xx=DOLX; else { xx = StartX2; yy = StartY2-CfirstDOLx*Step; } break; // 아래에서 위쪽으로      case 1 : xx = StartX2-CfirstDOLx*Step; yy = Y1; break; // 오른쪽에서 왼쪽으로      case 2 : xx = X1; yy = Y1+CfirstDOLx*Step; break; // 위에서 아래로      case 3 : xx = X1+CfirstDOLx*Step; yy = StartY2; break; // 왼쪽에서 오른쪽으로      case 4 : xx = StartX2-CfirstDOLx*step2; yy = Y1+CfirstDOLx*step2; break; // 오른쪽위대각선에서 왼쪽아래 대각선으로      case 5 : xx = X1+CfirstDOLx*step2; yy = Y1+CfirstDOLx*step2; break; // 왼쪽위 대각선에서 오른쪽아래 대각선으로                  }      }   if (which==2) {   switch (CsecondDOLy) {   case 0 : if (CsecondDOLx==0) xx=DOLX+R+5; else {xx = StartX2; yy = StartY2-CsecondDOLx*Step; } break; // 아래에서 위쪽으로      case 1 : xx = StartX2-CsecondDOLx*Step; yy = Y1; break; // 오른쪽에서 왼쪽으로      case 2 : xx = X1; yy = Y1+CsecondDOLx*Step; break; // 위에서 아래로      case 3 : xx = X1+CsecondDOLx*Step; yy = StartY2; break; // 왼쪽에서 오른쪽으로      case 4 : xx = StartX2-CsecondDOLx*step2; yy = Y1+CsecondDOLx*step2; break; // 오른쪽위대각선에서 왼쪽아래 대각선으로      case 5 : xx = X1+CsecondDOLx*step2; yy = Y1+CsecondDOLx*step2; break; // 왼쪽위 대각선에서 오른쪽아래 대각선으로                  }      }                  break; } return xx;}int CKBoardDlg::CaculateY(BOOL HumanOrCom){ int xx,yy; switch (HumanOrCom) {    case PERSON : if (which==1) {            switch (HfirstDOLy) {      case 0 : if (HfirstDOLx==0) yy=DOLY; else { xx = StartX2; yy = StartY2-HfirstDOLx*Step; } break; // 아래에서 위쪽으로      case 1 : xx = StartX2-HfirstDOLx*Step; yy = Y1; break; // 오른쪽에서 왼쪽으로      case 2 : xx = X1; yy = Y1+HfirstDOLx*Step; break; // 위에서 아래로      case 3 : xx = X1+HfirstDOLx*Step; yy = StartY2; break; // 왼쪽에서 오른쪽으로      case 4 : xx = StartX2-HfirstDOLx*step2; yy = Y1+HfirstDOLx*step2; break; // 오른쪽위대각선에서 왼쪽아래 대각선으로      case 5 : xx = X1+HfirstDOLx*step2; yy = Y1+HfirstDOLx*step2; break; // 왼쪽위 대각선에서 오른쪽아래 대각선으로                  }      }   if (which==2) {   switch (HsecondDOLy) {   case 0 : if (HsecondDOLx==0) yy=DOLY; else { xx = StartX2; yy = StartY2-HsecondDOLx*Step; } break; // 아래에서 위쪽으로      case 1 : xx = StartX2-HsecondDOLx*Step; yy = Y1; break; // 오른쪽에서 왼쪽으로      case 2 : xx = X1; yy = Y1+HsecondDOLx*Step; break; // 위에서 아래로      case 3 : xx = X1+HsecondDOLx*Step; yy = StartY2; break; // 왼쪽에서 오른쪽으로      case 4 : xx = StartX2-HsecondDOLx*step2; yy = Y1+HsecondDOLx*step2; break; // 오른쪽위대각선에서 왼쪽아래 대각선으로      case 5 : xx = X1+HsecondDOLx*step2; yy = Y1+HsecondDOLx*step2; break; // 왼쪽위 대각선에서 오른쪽아래 대각선으로                  }      }                  break;                   case COM : if (which==1) {            switch (CfirstDOLy) {      case 0 : if (CfirstDOLx==0) yy=DOLY+R+5; else { xx = StartX2; yy = StartY2-CfirstDOLx*Step; } break; // 아래에서 위쪽으로      case 1 : xx = StartX2-CfirstDOLx*Step; yy = Y1; break; // 오른쪽에서 왼쪽으로      case 2 : xx = X1; yy = Y1+CfirstDOLx*Step; break; // 위에서 아래로      case 3 : xx = X1+CfirstDOLx*Step; yy = StartY2; break; // 왼쪽에서 오른쪽으로      case 4 : xx = StartX2-CfirstDOLx*step2; yy = Y1+CfirstDOLx*step2; break; // 오른쪽위대각선에서 왼쪽아래 대각선으로      case 5 : xx = X1+CfirstDOLx*step2; yy = Y1+CfirstDOLx*step2; break; // 왼쪽위 대각선에서 오른쪽아래 대각선으로                  }      }   if (which==2) {   switch (CsecondDOLy) {   case 0 : if (CsecondDOLx==0) yy=DOLY+R+5; else {xx = StartX2; yy = StartY2-CsecondDOLx*Step; } break; // 아래에서 위쪽으로      case 1 : xx = StartX2-CsecondDOLx*Step; yy = Y1; break; // 오른쪽에서 왼쪽으로      case 2 : xx = X1; yy = Y1+CsecondDOLx*Step; break; // 위에서 아래로      case 3 : xx = X1+CsecondDOLx*Step; yy = StartY2; break; // 왼쪽에서 오른쪽으로      case 4 : xx = StartX2-CsecondDOLx*step2; yy = Y1+CsecondDOLx*step2; break; // 오른쪽위대각선에서 왼쪽아래 대각선으로      case 5 : xx = X1+CsecondDOLx*step2; yy = Y1+CsecondDOLx*step2; break; // 왼쪽위 대각선에서 오른쪽아래 대각선으로                  }      }                  break; } return yy;}void CKBoardDlg::DrawDOL(){ CClientDC dc(this); OldFont = (CFont *)dc.SelectObject(&m_Font); dc.SetTextColor(RGB(255,255,255)); dc.SetBkColor(RGB(0,0,255)); CBrush b,*pOB,b2,*pOB2; CBrush b3,*pOB3, b3_1, *pOB3_1, b4, *pOB4, b4_1, *pOB4_1; CBrush b5,*pOB5, b5_1, *pOB5_1, b6, *pOB6, b6_1, *pOB6_1;      if ((Shade>1) && (PaintCALL)) // 화면이 가려지면 다 그리기 {  CBrush greenDOL, *pODOL;  greenDOL.CreateSolidBrush(RGB(0,255,0));  pODOL = (CBrush *)dc.SelectObject(&greenDOL);  dc.Ellipse(DOLX,DOLY,DOLX+R,DOLY+R);  dc.Ellipse(DOLX+R+5,DOLY,DOLX+R+R+5,DOLY+R);  dc.Ellipse(DOLX,DOLY+R+5,DOLX+R,DOLY+R+R+5);  dc.Ellipse(DOLX+R+5,DOLY+R+5,DOLX+R+R+5,DOLY+R+R+5);  dc.SelectObject(pODOL);  b.CreateSolidBrush(RGB(0,0,255));        pOB = (CBrush *)dc.SelectObject(&b);  which = 1;  rx = CaculateX(PERSON);  ry = CaculateY(PERSON);  dc.Ellipse(rx,ry,rx+R,ry+R);  CString s="1";  if (HDOUBLE) s = "합";  if (HFirstDOLIn) s = "남";  dc.TextOut(rx+NUMX,ry+NUMY,s);      which = 2;  rx = CaculateX(PERSON);  ry = CaculateY(PERSON);  if (!HDOUBLE) dc.Ellipse(rx,ry,rx+R,ry+R);  s="2";  if (HSecondDOLIn) s = "남";  if (!HDOUBLE) dc.TextOut(rx+NUMX,ry+NUMY,s);  dc.SelectObject(pOB);  dc.SetBkColor(RGB(255,0,0));  b2.CreateSolidBrush(RGB(255,0,0));        pOB2 = (CBrush *)dc.SelectObject(&b2);  which = 1;  rx = CaculateX(COM);  ry = CaculateY(COM);  dc.Ellipse(rx,ry,rx+R,ry+R);  s="1";  if (CDOUBLE) s = "합";  if (CFirstDOLIn) s = "남";  dc.TextOut(rx+NUMX,ry+NUMY,s);  which = 2;  rx = CaculateX(COM);  ry = CaculateY(COM);  if (!CDOUBLE) dc.Ellipse(rx,ry,rx+R,ry+R);  s="2";  if (CSecondDOLIn) s = "남";  if (!CDOUBLE) dc.TextOut(rx+NUMX,ry+NUMY,s);  dc.SelectObject(pOB2);  PaintCALL = FALSE; } else  { CBrush b,*pOB,b2,*pOB2; CBrush b3,*pOB3, b3_1, *pOB3_1, b4, *pOB4, b4_1, *pOB4_1; CBrush b5,*pOB5, b5_1, *pOB5_1, b6, *pOB6, b6_1, *pOB6_1;     if ((mode==START) || (CAPTURE==TRUE)) { b.CreateSolidBrush(RGB(0,0,255)); pOB = (CBrush *)dc.SelectObject(&b); if ((mode==START) || (HfirstDOLC)) { dc.Ellipse(DOLX,DOLY,DOLX+R,DOLY+R); // 사람돌 그리기 dc.TextOut(DOLX+NUMX,DOLY+NUMY,"1"); } if ((mode==START) || (HsecondDOLC)) { dc.Ellipse(DOLX+R+5,DOLY,DOLX+R+R+5,DOLY+R); dc.TextOut(DOLX+R+5+NUMX,DOLY+NUMY,"2"); } dc.SelectObject(pOB); dc.SetBkColor(RGB(255,0,0)); b2.CreateSolidBrush(RGB(255,0,0)); pOB2 = (CBrush *)dc.SelectObject(&b2); if ((mode==START) || (CfirstDOLC)) { dc.Ellipse(DOLX,DOLY+R+5,DOLX+R,DOLY+R+R+5); // 컴퓨터돌 그리기 dc.TextOut(DOLX+NUMX,DOLY+R+5+NUMY,"1"); } if ((mode==START) || (CsecondDOLC)) {  dc.Ellipse(DOLX+R+5,DOLY+R+5,DOLX+R+R+5,DOLY+R+R+5); dc.TextOut(DOLX+R+5+NUMX,DOLY+R+5+NUMY,"2"); } dc.SelectObject(pOB2); }    if ((whichturn==PERSON) && (Run<2) && (mode!=START)) {   if (!HDOUBLE) {   switch (MDOL[0].num) { // 사람 첫번째 돌이면   case 1 : if (!HFirstDOLIn) {    b3.CreateSolidBrush(RGB(0,255,0));   pOB3 = (CBrush *)dc.SelectObject(&b3);   dc.Ellipse(DOLX,DOLY,DOLX+R,DOLY+R); // 대기 사람돌 그리기   dc.SelectObject(pOB3);   b4.CreateSolidBrush(RGB(0,0,255));   pOB4 = (CBrush *)dc.SelectObject(&b4);   dc.SetTextColor(RGB(255,255,255));   dc.SetBkColor(RGB(0,0,255));   dc.Ellipse(PanDOLX,PanDOLY,PanDOLX+R,PanDOLY+R); // 판에 사람돌 그리기   dc.TextOut(PanDOLX+NUMX,PanDOLY+NUMY,"1");   dc.SelectObject(pOB4);   }   break;   case 2 : if (!HSecondDOLIn) {   b3.CreateSolidBrush(RGB(0,255,0));   pOB3 = (CBrush *)dc.SelectObject(&b3);   dc.Ellipse(DOLX+R+5,DOLY,DOLX+R+R+5,DOLY+R); // 대기 사람돌 그리기   dc.SelectObject(pOB3);   b4.CreateSolidBrush(RGB(0,0,255));   pOB4 = (CBrush *)dc.SelectObject(&b4);   dc.SetTextColor(RGB(255,255,255));   dc.SetBkColor(RGB(0,0,255));   dc.Ellipse(PanDOLX,PanDOLY,PanDOLX+R,PanDOLY+R); // 판에 사람돌 그리기   dc.TextOut(PanDOLX+NUMX,PanDOLY+NUMY,"2");   dc.SelectObject(pOB4);   }   break;   }    } else if (HDOUBLE) // 합치기이면      {      b3_1.CreateSolidBrush(RGB(0,255,0));      pOB3_1 = (CBrush *)dc.SelectObject(&b3_1);      dc.Ellipse(DOLX+R+5,DOLY,DOLX+R+R+5,DOLY+R); // 대기 사람돌 그리기      dc.SelectObject(pOB3_1);            b4_1.CreateSolidBrush(RGB(0,0,255));      pOB4_1 = (CBrush *)dc.SelectObject(&b4_1);      dc.SetTextColor(RGB(255,255,255));      dc.SetBkColor(RGB(0,0,255));      dc.Ellipse(PanDOLX,PanDOLY,PanDOLX+R,PanDOLY+R); // 판에 사람돌 그리기      dc.TextOut(PanDOLX+NUMX,PanDOLY+NUMY,"합");      dc.SelectObject(pOB4_1);     }  }         if ((whichturn==COM) && (Run<2) && (mode!=START)) {  if (!CDOUBLE) {   switch (MDOL[1].num) { // 컴퓨터 첫번째 돌이면   case 1 : if (!CFirstDOLIn) {   b5.CreateSolidBrush(RGB(0,255,0));   pOB5 = (CBrush *)dc.SelectObject(&b5);   dc.Ellipse(DOLX,DOLY+R+5,DOLX+R,DOLY+R+R+5); // 컴퓨터돌 그리기   dc.SelectObject(pOB5);   b6.CreateSolidBrush(RGB(255,0,0));   pOB6 = (CBrush *)dc.SelectObject(&b6);   dc.SetTextColor(RGB(255,255,255));   dc.SetBkColor(RGB(255,0,0));   dc.Ellipse(PanDOLX,PanDOLY,PanDOLX+R,PanDOLY+R); // 판에 컴퓨터돌 그리기   dc.TextOut(PanDOLX+NUMX,PanDOLY+NUMY,"1");   dc.SelectObject(pOB6);   }   break;   case 2 : if (!CSecondDOLIn) {   b5.CreateSolidBrush(RGB(0,255,0));   pOB5 = (CBrush *)dc.SelectObject(&b5);   dc.Ellipse(DOLX+R+5,DOLY+R+5,DOLX+R+R+5,DOLY+R+R+5); // 컴퓨터돌 그리기   dc.SelectObject(pOB5);   b6.CreateSolidBrush(RGB(255,0,0));   pOB6 = (CBrush *)dc.SelectObject(&b6);   dc.SetTextColor(RGB(255,255,255));   dc.SetBkColor(RGB(255,0,0));   dc.Ellipse(PanDOLX,PanDOLY,PanDOLX+R,PanDOLY+R); // 판에 컴퓨터돌 그리기   dc.TextOut(PanDOLX+NUMX,PanDOLY+NUMY,"2");   dc.SelectObject(pOB6);   }   break;   } } else if (CDOUBLE) // 합치기이면      {      b5_1.CreateSolidBrush(RGB(0,255,0));      pOB5_1 = (CBrush *)dc.SelectObject(&b5_1);      dc.Ellipse(DOLX+R+5,DOLY+R+5,DOLX+R+R+5,DOLY+R+R+5); // 컴퓨터돌 그리기      dc.SelectObject(pOB5_1);            b6_1.CreateSolidBrush(RGB(255,0,0));      pOB6_1 = (CBrush *)dc.SelectObject(&b6_1);      dc.SetTextColor(RGB(255,255,255));      dc.SetBkColor(RGB(255,0,0));      dc.Ellipse(PanDOLX,PanDOLY,PanDOLX+R,PanDOLY+R); // 판에 사람돌 그리기      dc.TextOut(PanDOLX+NUMX,PanDOLY+NUMY,"합");      dc.SelectObject(pOB6_1); } } } CBrush b7,b8,b9,b10,*pOB7, *pOB8, *pOB9, *pOB10; if (HFirstDOLIn) {  dc.SetBkColor(RGB(0,0,255));  b7.CreateSolidBrush(RGB(0,0,255));  pOB7 = (CBrush *)dc.SelectObject(&b7);  dc.Ellipse(DOLX,DOLY,DOLX+R,DOLY+R);  dc.TextOut(DOLX+NUMX,DOLY+NUMY,"남");  dc.SelectObject(pOB7); } if (HSecondDOLIn) {  dc.SetBkColor(RGB(0,0,255));  b8.CreateSolidBrush(RGB(0,0,255));  pOB8 = (CBrush *)dc.SelectObject(&b8);  dc.Ellipse(DOLX+R+5,DOLY,DOLX+R+R+5,DOLY+R);  dc.TextOut(DOLX+R+NUMX,DOLY+NUMY,"남");  dc.SelectObject(pOB8); } if (CFirstDOLIn) {  dc.SetBkColor(RGB(255,0,0));  b9.CreateSolidBrush(RGB(255,0,0));  pOB9 = (CBrush *)dc.SelectObject(&b9);  dc.Ellipse(DOLX,DOLY+R+5,DOLX+R,DOLY+R+R+5);  dc.TextOut(DOLX+NUMX,DOLY+R+5+NUMY,"남");  dc.SelectObject(pOB9); } if (CSecondDOLIn) {  dc.SetBkColor(RGB(255,0,0));  b10.CreateSolidBrush(RGB(255,0,0));  pOB10 = (CBrush *)dc.SelectObject(&b10);  dc.Ellipse(DOLX+R+5,DOLY+R+5,DOLX+R+R+5,DOLY+R+R+5);  dc.TextOut(DOLX+R+5+NUMX,DOLY+R+5+NUMY,"남");  dc.SelectObject(pOB10); }}void CKBoardDlg::DrawPan(){ CClientDC dc(this); int x,y; x = StartX2; y = StartY2; dc.MoveTo(x,y); dc.Ellipse(x,y,x+R,y+R);    for (int j=0;j<4;j++) { for (int i=0;i<5;i++) {  switch(j) {  case 0 : y = y-Step; break;  case 1 : x = x-Step; break;  case 2 : y = y+Step; break;  case 3 : x = x+Step; break;  }  dc.MoveTo(x,y);  dc.Ellipse(x,y,x+R,y+R); } }  step2 = (StartX2-X1)/6; for (j=0;j<2;j++) {  if (j==0) { x=StartX2; y=StartY2; }  else { x= X1; y = StartY2; }  for (int i=0;i<6;i++) {   switch(j) {   case 0 : x=x-step2; y=y-step2; break;   case 1 : x=x+step2; y=y-step2; break;   }  dc.Ellipse(x,y,x+R,y+R);  } } // 돌그리기 - 사람돌 파란돌 컴퓨터돌 빨간돌 DrawDOL(); DrawY();}BOOL CKBoardDlg::OnInitDialog(){ CDialog::OnInitDialog(); // Set the icon for this dialog.  The framework does this automatically //  when the application's main window is not a dialog SetIcon(m_hIcon, TRUE);   // Set big icon SetIcon(m_hIcon, FALSE);  // Set small icon  // TODO: Add extra initialization here  Step = (StartY2-Y1)/5; PersonDOL = 2; ComDOL = 2; MDOL[0].x1 = 0; MDOL[0].y1=0; MDOL[1].x1 = 0; MDOL[1].y1=0; MDOL[0].x2 = 0; MDOL[0].y2=0; MDOL[1].x2 = 0; MDOL[1].y2=0; MDOL[0].which = PERSON; MDOL[0].num=1;  MDOL[1].which = COM; MDOL[1].num=1; Move_Count = 0; CMove_Count = 0; whichturn = PERSON; // 누구차례인지 mode = START; SetDlgItemText(IDC_NOTICE,"먼저 던지세요!");    Pone = TRUE; Cone = TRUE; COM1or2 = 1; PERSON1or2 = 1; // 첫번째돌 HFirstDOLIn=FALSE; HSecondDOLIn=FALSE; CFirstDOLIn=FALSE; CSecondDOLIn=FALSE; HDOUBLE=FALSE; CDOUBLE=FALSE; ONEMORE = FALSE; CAPTURE = FALSE; if (Run==1) {  m_Font.CreatePointFont(120,_T("Time New Romans"));  Edit_Font.CreatePointFont(300,"굴림체");  GetDlgItem(IDC_NOTICE)->SetFont(&Edit_Font);   }    HfirstDOLx = 0; HfirstDOLy = 0; CfirstDOLx = 0; CfirstDOLy = 0; HsecondDOLx = 0; HsecondDOLy = 0; CsecondDOLx = 0; CsecondDOLy = 0; WhoWin = 0; Shade=0; PaintCALL = FALSE; srand(GetCurrentTime()); return TRUE;  // return TRUE  unless you set the focus to a control}// If you add a minimize button to your dialog, you will need the code below//  to draw the icon.  For MFC applications using the document/view model,//  this is automatically done for you by the framework.void CKBoardDlg::OnPaint() { if (IsIconic()) {  CPaintDC dc(this); // device context for painting  SendMessage(WM_ICONERASEBKGND, (WPARAM) dc.GetSafeHdc(), 0);  // Center icon in client rectangle  int cxIcon = GetSystemMetrics(SM_CXICON);  int cyIcon = GetSystemMetrics(SM_CYICON);  CRect rect;  GetClientRect(&rect);  int x = (rect.Width() - cxIcon + 1) / 2;  int y = (rect.Height() - cyIcon + 1) / 2;  // Draw the icon  dc.DrawIcon(x, y, m_hIcon); } else {  CDialog::OnPaint(); } DrawPan(); Shade++; if (Shade>1) { Shade=2; PaintCALL= TRUE; }}// The system calls this to obtain the cursor to display while the user drags//  the minimized window.HCURSOR CKBoardDlg::OnQueryDragIcon(){ return (HCURSOR) m_hIcon;}BOOL CKBoardDlg::PWait(int i){ switch (i) { case 1 : if ((MDOL[0].x1==0) && (MDOL[0].y1==0) && (MDOL[1].x1==0) && (MDOL[1].y1==0)) return TRUE; else return FALSE; case 2 : if ((MDOL[0].x1==0) && (MDOL[0].y1==0) && (MDOL[1].x2==0) && (MDOL[1].y2==0)) return TRUE; else return FALSE; case 3 : if ((MDOL[0].x2==0) && (MDOL[0].y2==0) && (MDOL[1].x1==0) && (MDOL[1].y1==0)) return TRUE; else return FALSE; case 4 : if ((MDOL[0].x2==0) && (MDOL[0].y2==0) && (MDOL[1].x2==0) && (MDOL[1].y2==0)) return TRUE; else return FALSE; }}BOOL CKBoardDlg::CWait(int j){ switch (j) { case 1 : if ((MDOL[1].x1==0) && (MDOL[1].y1==0) && (MDOL[0].x1==0) && (MDOL[0].y1==0)) return TRUE; else return FALSE; case 2 : if ((MDOL[1].x1==0) && (MDOL[1].y1==0) && (MDOL[0].x2==0) && (MDOL[0].y2==0)) return TRUE; else return FALSE; case 3 : if ((MDOL[1].x2==0) && (MDOL[1].y2==0) && (MDOL[0].x1==0) && (MDOL[0].y1==0)) return TRUE; else return FALSE; case 4 : if ((MDOL[1].x2==0) && (MDOL[1].y2==0) && (MDOL[0].x2==0) && (MDOL[0].y2==0)) return TRUE; else return FALSE; }}void CKBoardDlg::Move(){ CClientDC dc(this); // 좌표로 변환 int x,y; if (whichturn==PERSON) {  if (PERSON1or2==1) { switch (MDOL[0].y1) { case 0 : x = StartX2; y = StartY2-MDOL[0].x1*Step; break; // 아래에서 위쪽으로 case 1 : x = StartX2-MDOL[0].x1*Step; y = Y1; break; // 오른쪽에서 왼쪽으로 case 2 : x = X1; y = Y1+MDOL[0].x1*Step; break; // 위에서 아래로 case 3 : x = X1+MDOL[0].x1*Step; y = StartY2; break; // 왼쪽에서 오른쪽으로 case 4 : x = StartX2-MDOL[0].x1*step2; y = Y1+MDOL[0].x1*step2; break; // 오른쪽위대각선에서 왼쪽아래 대각선으로 case 5 : x = X1+MDOL[0].x1*step2; y = Y1+MDOL[0].x1*step2; break; // 왼쪽위 대각선에서 오른쪽아래 대각선으로 } } else { switch (MDOL[0].y2) { case 0 : x = StartX2; y = StartY2-MDOL[0].x2*Step; break; // 아래에서 위쪽으로 case 1 : x = StartX2-MDOL[0].x2*Step; y = Y1; break; // 오른쪽에서 왼쪽으로 case 2 : x = X1; y = Y1+MDOL[0].x2*Step; break; // 위에서 아래로 case 3 : x = X1+MDOL[0].x2*Step; y = StartY2; break; // 왼쪽에서 오른쪽으로 case 4 : x = StartX2-MDOL[0].x2*step2; y = Y1+MDOL[0].x2*step2; break; // 오른쪽위대각선에서 왼쪽아래 대각선으로 case 5 : x = X1+MDOL[0].x2*step2; y = Y1+MDOL[0].x2*step2; break; // 왼쪽위 대각선에서 오른쪽아래 대각선으로 } } } if (whichturn==COM) {  if (COM1or2==1) { switch (MDOL[1].y1) { case 0 : x = StartX2; y = StartY2-MDOL[1].x1*Step; break; // 아래에서 위쪽으로 case 1 : x = StartX2-MDOL[1].x1*Step; y = Y1; break; // 오른쪽에서 왼쪽으로 case 2 : x = X1; y = Y1+MDOL[1].x1*Step; break; // 위에서 아래로 case 3 : x = X1+MDOL[1].x1*Step; y = StartY2; break; // 왼쪽에서 오른쪽으로 case 4 : x = StartX2-MDOL[1].x1*step2; y = Y1+MDOL[1].x1*step2; break; // 오른쪽위대각선에서 왼쪽아래 대각선으로 case 5 : x = X1+MDOL[1].x1*step2; y = Y1+MDOL[1].x1*step2; break; // 왼쪽위 대각선에서 오른쪽아래 대각선으로 } } else { switch (MDOL[1].y2) { case 0 : x = StartX2; y = StartY2-MDOL[1].x2*Step; break; // 아래에서 위쪽으로 case 1 : x = StartX2-MDOL[1].x2*Step; y = Y1; break; // 오른쪽에서 왼쪽으로 case 2 : x = X1; y = Y1+MDOL[1].x2*Step; break; // 위에서 아래로 case 3 : x = X1+MDOL[1].x2*Step; y = StartY2; break; // 왼쪽에서 오른쪽으로 case 4 : x = StartX2-MDOL[1].x2*step2; y = Y1+MDOL[1].x2*step2; break; // 오른쪽위대각선에서 왼쪽아래 대각선으로 case 5 : x = X1+MDOL[1].x2*step2; y = Y1+MDOL[1].x2*step2; break; // 왼쪽위 대각선에서 오른쪽아래 대각선으로 } } } EraseDOL();    PanDOLX = x; PanDOLY = y;    if (((MDOL[0].x1==MDOL[0].x2) && (MDOL[0].y1==MDOL[0].y2)) && (!((MDOL[0].x1==0) && (MDOL[0].y1==0))) && (!((MDOL[0].x2==0) && (MDOL[0].y2==0)))) // 합치기  { HDOUBLE=TRUE; MDOL[0].x2 = 0; MDOL[0].y2=0; HfirstDOLC = FALSE; HsecondDOLC = FALSE; }   if (((MDOL[1].x1==MDOL[1].x2) && (MDOL[1].y1==MDOL[1].y2)) && (!((MDOL[1].x1==0) && (MDOL[1].y1==0))) && (!((MDOL[1].x2==0) && (MDOL[1].y2==0)))) // 합치기  { CDOUBLE=TRUE; MDOL[1].x2 = 0; MDOL[1].y2 = 0; COM1or2=1; CfirstDOLC = FALSE; CsecondDOLC = FALSE; }     // 잡아먹기 switch (whichturn) {  case PERSON : if ((MDOL[0].x1==MDOL[1].x1) && (MDOL[0].y1==MDOL[1].y1) && (!PWait(1))) // 사람첫돌이 컴퓨터 첫돌을 잡았을때       {        MDOL[1].x1=0; MDOL[1].y1=0; CfirstDOLx=0; CfirstDOLy=0;         if (CDOUBLE) { MDOL[1].x2=0; MDOL[1].y2=0; CsecondDOLx=0; CsecondDOLy=0; CsecondDOLC=TRUE; }        CDOUBLE=FALSE; ONEMORE = TRUE; CfirstDOLC = TRUE; CAPTURE=TRUE;        }             else if ((MDOL[0].x1==MDOL[1].x2) && (MDOL[0].y1==MDOL[1].y2) && (!PWait(2))) // 사람첫돌이 컴퓨터 둘째돌을 잡았을때       {        MDOL[1].x2=0; MDOL[1].y2=0; CsecondDOLx=0; CsecondDOLy=0;         if (CDOUBLE) { MDOL[1].x1=0; MDOL[1].y1=0; CfirstDOLx=0; CfirstDOLy=0; CfirstDOLC = TRUE; }        CDOUBLE=FALSE; ONEMORE = TRUE; CsecondDOLC = TRUE; CAPTURE=TRUE; CDOUBLE = FALSE;       }              if ((MDOL[0].x2==MDOL[1].x1) && (MDOL[0].y2==MDOL[1].y1) && (!PWait(3))) // 사람둘째돌이 컴퓨터 첫돌을 잡았을때       {        MDOL[1].x1=0; MDOL[1].y1=0; CfirstDOLx=0; CfirstDOLy=0;         if (CDOUBLE) { MDOL[1].x2=0; MDOL[1].y2=0; CsecondDOLx=0; CsecondDOLy=0; CsecondDOLC=TRUE; }        CDOUBLE=FALSE; ONEMORE = TRUE; CfirstDOLC = TRUE; CAPTURE=TRUE; CDOUBLE = FALSE;        }             else if ((MDOL[0].x2==MDOL[1].x2) && (MDOL[0].y2==MDOL[1].y2) && (!PWait(4))) // 사람둘째돌이 컴퓨터 둘째돌을 잡았을때       {        MDOL[1].x2=0; MDOL[1].y2=0; CsecondDOLx=0; CsecondDOLy=0;         if (CDOUBLE) { MDOL[1].x1=0; MDOL[1].y1=0; CfirstDOLx=0; CfirstDOLy=0; CfirstDOLC=TRUE; }        CDOUBLE=FALSE; ONEMORE = TRUE; CsecondDOLC = TRUE; CAPTURE=TRUE; CDOUBLE = FALSE;       }       break;  case COM :  if ((MDOL[1].x1==MDOL[0].x1) && (MDOL[1].y1==MDOL[0].y1) && (!CWait(1))) // 컴퓨터 첫째돌이 사람 첫돌을 잡았을때       {        MDOL[0].x1=0; MDOL[0].y1=0; HfirstDOLx=0; HfirstDOLy=0;         if (HDOUBLE) { MDOL[0].x2=0; MDOL[0].y2=0; HsecondDOLx=0; HsecondDOLy=0; HsecondDOLC=TRUE; }        HDOUBLE=FALSE; CONEMORE = TRUE; HfirstDOLC = TRUE; CAPTURE=TRUE;        }             else if ((MDOL[1].x1==MDOL[0].x2) && (MDOL[1].y1==MDOL[0].y2) && (!CWait(2))) // 컴퓨터 첫째돌이 사람 둘째돌을 잡았을때       {        MDOL[0].x2=0; MDOL[0].y2=0; HsecondDOLx=0; HsecondDOLy=0;         if (HDOUBLE) { MDOL[0].x1=0; MDOL[0].y1=0; HfirstDOLx=0; HfirstDOLy=0; HfirstDOLC=TRUE; }        HDOUBLE=FALSE; CONEMORE = TRUE; HsecondDOLC = TRUE; CAPTURE=TRUE;       }              if ((MDOL[1].x2==MDOL[0].x1) && (MDOL[1].y2==MDOL[0].y1) && (!CWait(3))) // 컴퓨터 둘째돌이 사람 첫돌을 잡았을때       {        MDOL[0].x1=0; MDOL[0].y1=0; HfirstDOLx=0; HfirstDOLy=0;         if (HDOUBLE) { MDOL[0].x2=0; MDOL[0].y2=0; HsecondDOLx=0; HsecondDOLy=0; HsecondDOLC=TRUE; }        HDOUBLE=FALSE; CONEMORE = TRUE; HfirstDOLC = TRUE; CAPTURE=TRUE;       }             else if ((MDOL[1].x2==MDOL[0].x2) && (MDOL[1].y2==MDOL[0].y2) && (!CWait(4))) // 컴퓨터 둘째돌이 사람 둘째돌을 잡았을때       {        MDOL[0].x2=0; MDOL[0].y2=0; HsecondDOLx=0; HsecondDOLy=0;         if (HDOUBLE) { MDOL[0].x1=0; MDOL[0].y1=0; HfirstDOLx=0; HfirstDOLy=0; HfirstDOLC = TRUE; }        HDOUBLE=FALSE; CONEMORE = TRUE; HsecondDOLC = TRUE; CAPTURE=TRUE;       }       break;         } DrawDOL(); if ((ONEMORE) || (CONEMORE)) SetDlgItemText(IDC_NOTICE,"한번더!"); HfirstDOLC = FALSE; HsecondDOLC = FALSE; CfirstDOLC = FALSE; CsecondDOLC = FALSE;}void CKBoardDlg::GAMEAGAIN(){CString s;int r=0;switch (WhoWin) {case 1 : s = "사람이 이겼습니다! 한번더 하시겠습니까?"; break;case 2 : s = "컴퓨터가 이겼습니다! 한번더 하시겠습니까?"; break;}if (AfxMessageBox(s,MB_YESNO)==IDYES) {  AGAIN=TRUE; Run=2; OnInitDialog(); DrawPan(); Run=1; GetDlgItem(IDC_GO)->EnableWindow(TRUE); } else EndDialog(r);}void CKBoardDlg::ComTurn(){ CONEMORE = FALSE; CAPTURE = FALSE; if (CDOUBLE) COM1or2=1; if (CFirstDOLIn) COM1or2 = 2; if (CSecondDOLIn) COM1or2 = 1; SetDlgItemText(IDC_NOTICE,"컴퓨터가 던집니다!!"); Sleep(500); CY2[0] = rand()%2;  CY2[1] = rand()%2;  CY2[2] = rand()%2;  CY2[3] = rand()%2;    DrawY();    Cpae = CY2[0]+CY2[1]+CY2[2]+CY2[3]; switch(Cpae) { case 0 : Cpae_Str = "윷"; CMove_Count = 4; break; case 1 : Cpae_Str = "도"; CMove_Count = 1; break; case 2 : Cpae_Str = "개"; CMove_Count = 2; break; case 3 : Cpae_Str = "걸"; CMove_Count = 3; break; case 4 : Cpae_Str = "모"; CMove_Count = 5; break; } SetDlgItemText(IDC_NOTICE,Cpae_Str); if (COM1or2==1) {  CfirstDOLx = MDOL[1].x1;  MDOL[1].x1 = MDOL[1].x1+CMove_Count;  MDOL[1].num = 1;    if (((MDOL[1].x1>5) && (MDOL[1].y1==3)) || ((MDOL[1].x1>6) && (MDOL[1].y1==5))) // 낫으면  { if (CDOUBLE) {WhoWin=2; GAMEAGAIN(); } else { CFirstDOLIn = TRUE; DrawDOL(); exit;} }           if (((MDOL[1].x2>5) && (MDOL[1].y2==3)) || ((MDOL[1].x2>6) && (MDOL[1].y2==5))) // 낫으면  { CSecondDOLIn = TRUE; DrawDOL(); exit;}   if ((MDOL[1].y1>=0) && (MDOL[1].y1<=3)) {   if (MDOL[1].x1>5)    { MDOL[1].x1 = MDOL[1].x1-5; CfirstDOLy = MDOL[1].y1; MDOL[1].y1++; }   else if (MDOL[1].x1==5) {    switch (MDOL[1].y1) {    case 0 : MDOL[1].x1=0; MDOL[1].y1=4; break; // 첫번째 모자리-방향이 왼쪽대각선쪽으로 바뀜    case 1 : MDOL[1].x1=0; MDOL[1].y1=5; break; // 두번째 모자리-방향이 오른쪽대각선쪽으로 바뀜    }   }  } else if ((MDOL[1].x1==3) && (MDOL[1].y1==4)) // 한가운데 방향 바꾸기      MDOL[1].y1=5;  else if ((MDOL[1].x1>6) && (MDOL[1].y1==4)) // 가운데에서 밖으로 빠져나오는 경우  {  MDOL[1].x1 = MDOL[1].x1-6; MDOL[1].y1 = 3;  } } else {  CsecondDOLx = MDOL[1].x2;  MDOL[1].x2 = MDOL[1].x2+CMove_Count;  MDOL[1].num = 2;  if (((MDOL[1].x2>5) && (MDOL[1].y2==3)) || ((MDOL[1].x2>6) && (MDOL[1].y2==5))) // 낫으면  { if (CDOUBLE) { WhoWin=2; GAMEAGAIN(); } else { CFirstDOLIn = TRUE; DrawDOL(); exit;} }           if (((MDOL[1].x2>5) && (MDOL[1].y2==3)) || ((MDOL[1].x2>6) && (MDOL[1].y2==5))) // 낫으면  { CSecondDOLIn = TRUE; DrawDOL(); exit;}   if ((MDOL[1].y2>=0) && (MDOL[1].y2<=3)) {   if (MDOL[1].x2>5)    { MDOL[1].x2 = MDOL[1].x2-5; CsecondDOLy = MDOL[1].y2; MDOL[1].y2++;}   else if (MDOL[1].x2==5) {    switch (MDOL[1].y2) {    case 0 : MDOL[1].x2=0; MDOL[1].y2=4; break; // 첫번째 모자리-방향이 왼쪽대각선쪽으로 바뀜    case 1 : MDOL[1].x2=0; MDOL[1].y2=5; break; // 두번째 모자리-방향이 오른쪽대각선쪽으로 바뀜    }   }  } else if ((MDOL[1].x2==3) && (MDOL[1].y2==4)) // 한가운데 방향 바꾸기    MDOL[1].y2=5;  else if ((MDOL[1].x2>6) && (MDOL[1].y2==4)) // 가운데에서 밖으로 빠져나오는 경우  {   MDOL[1].x2 = MDOL[1].x2-6; MDOL[1].y2 = 3;  } }   mode++; if (mode>2) mode = 2; m_notice = Cpae_Str; UpdateData(FALSE); Move(); Cone = FALSE; CfirstDOLx = MDOL[1].x1; CfirstDOLy = MDOL[1].y1; CfirstDOLy = MDOL[1].y1; CsecondDOLy = MDOL[1].y2; if (Pone) { CfirstDOLx = CMove_Count; CfirstDOLy = 0; }; if ((CMove_Count==4) || (CMove_Count==5))   CONEMORE = TRUE; if (!CONEMORE) { if (COM1or2==1) COM1or2 = 2; else COM1or2 = 1; // 첫번째면 두번째 돌 움직일차례, 두번째돌이면 첫번째돌 움직일 차례  MDOL[1].num = COM1or2; whichturn = PERSON; } if (CONEMORE) { Sleep(500); ComTurn(); CONEMORE=FALSE; } if ((CFirstDOLIn) && (CSecondDOLIn)) { WhoWin=2; GAMEAGAIN(); }}void CKBoardDlg::OnGo() { // TODO: Add your control notification handler code here whichturn = PERSON; CAPTURE = FALSE; PaintCALL = FALSE; if (Pone) { Y[0] = rand()%2;  Y[1] = rand()%2;  Y[2] = rand()%2;  Y[3] = rand()%2;    DrawY();    pae = Y[0]+Y[1]+Y[2]+Y[3]; switch(pae) { case 0 : pae_Str = "윷"; Move_Count = 4; break; case 1 : pae_Str = "도"; Move_Count = 1; break; case 2 : pae_Str = "개"; Move_Count = 2; break; case 3 : pae_Str = "걸"; Move_Count = 3; break; case 4 : pae_Str = "모"; Move_Count = 5; break; } SetDlgItemText(IDC_NOTICE,""); SetDlgItemText(IDC_NOTICE,pae_Str); HfirstDOLx = MDOL[0].x1; MDOL[0].x1 = MDOL[0].x1+Move_Count; MDOL[0].num = 1; if (((MDOL[0].x1>5) && (MDOL[0].y1==3)) || ((MDOL[0].x1>6) && (MDOL[0].y1==5))) // 낫으면 {   if ((HDOUBLE) || (HSecondDOLIn)) { WhoWin=1; GAMEAGAIN(); } else {HFirstDOLIn = TRUE; DrawDOL(); exit;}     }     if (!AGAIN) { if ((MDOL[0].y1>=0) && (MDOL[0].y1<=3)) {  if (MDOL[0].x1>5)   { MDOL[0].x1 = MDOL[0].x1-5;HfirstDOLy = MDOL[0].y1; MDOL[0].y1++; }  else if (MDOL[0].x1==5) {   switch (MDOL[0].y1) {   case 0 : MDOL[0].x1=0; MDOL[0].y1=4; break; // 첫번째 모자리-방향이 왼쪽대각선쪽으로 바뀜   case 1 : MDOL[0].x1=0; MDOL[0].y1=5; break; // 두번째 모자리-방향이 오른쪽대각선쪽으로 바뀜   }  } } else if ((MDOL[0].x1==3) && (MDOL[0].y1==4)) // 한가운데 방향 바꾸기  MDOL[0].y1=5; else if ((MDOL[0].x1>6) && (MDOL[0].y1==4)) // 가운데에서 밖으로 빠져나오는 경우 {  MDOL[0].x1 = MDOL[0].x1-6; MDOL[0].y1 = 3; }  m_notice = pae_Str; SetDlgItemText(IDC_NOTICE,m_notice); mode++; if (mode>2) mode = 2; Move(); HfirstDOLx = MDOL[0].x1; HfirstDOLy = MDOL[0].y1; Sleep(500); Pone = FALSE; if ((Move_Count==4) || (Move_Count==5)) { ONEMORE = TRUE; SetDlgItemText(IDC_NOTICE,"한번더!!"); }  if (ONEMORE) { Sleep(500); exit;} if (!ONEMORE) whichturn = COM; if (whichturn==COM) {   ComTurn();    if (CONEMORE)   { Sleep(500);     ComTurn();     CONEMORE=FALSE;   }  } GetDlgItem(IDC_GO)->EnableWindow(TRUE); GetDlgItem(IDC_DOL1)->EnableWindow(FALSE); GetDlgItem(IDC_DOL2)->EnableWindow(FALSE); } }    else { Y[0] = rand()%2;  Y[1] = rand()%2;  Y[2] = rand()%2;  Y[3] = rand()%2;    DrawY();    pae = Y[0]+Y[1]+Y[2]+Y[3]; switch(pae) { case 0 : pae_Str = "윷"; Move_Count = 4; break; case 1 : pae_Str = "도"; Move_Count = 1; break; case 2 : pae_Str = "개"; Move_Count = 2; break; case 3 : pae_Str = "걸"; Move_Count = 3; break; case 4 : pae_Str = "모"; Move_Count = 5; break; }    SetDlgItemText(IDC_NOTICE,pae_Str); Sleep(500); GetDlgItem(IDC_GO)->EnableWindow(FALSE); GetDlgItem(IDC_DOL1)->EnableWindow(TRUE); GetDlgItem(IDC_DOL2)->EnableWindow(TRUE); } if (HFirstDOLIn) GetDlgItem(IDC_DOL1)->EnableWindow(FALSE); if (HSecondDOLIn) GetDlgItem(IDC_DOL2)->EnableWindow(FALSE); if (HDOUBLE) GetDlgItem(IDC_DOL2)->EnableWindow(FALSE); if (ONEMORE) { ONEMORE = FALSE; CAPTURE = FALSE; }}void CKBoardDlg::OnDol1() { // TODO: Adzad your control notification handler code here    // 첫번째돌 움직이기 클릭했을때 if (!HFirstDOLIn) { PERSON1or2 = 1; HfirstDOLx = MDOL[0].x1; MDOL[0].x1 = MDOL[0].x1+Move_Count; MDOL[0].num = 1; if (((MDOL[0].x1>5) && (MDOL[0].y1==3)) || ((MDOL[0].x1>6) && (MDOL[0].y1==5))) // 낫으면 {   if ((HDOUBLE) || (HSecondDOLIn)) { WhoWin=1; GAMEAGAIN(); } else {HFirstDOLIn = TRUE; DrawDOL(); exit;}     }     if (!AGAIN) { if ((MDOL[0].y1>=0) && (MDOL[0].y1<=3)) {  if (MDOL[0].x1>5)   { MDOL[0].x1 = MDOL[0].x1-5;HfirstDOLy = MDOL[0].y1; MDOL[0].y1++; }  else if (MDOL[0].x1==5) {   switch (MDOL[0].y1) {   case 0 : MDOL[0].x1=0; MDOL[0].y1=4; break; // 첫번째 모자리-방향이 왼쪽대각선쪽으로 바뀜   case 1 : MDOL[0].x1=0; MDOL[0].y1=5; break; // 두번째 모자리-방향이 오른쪽대각선쪽으로 바뀜   }  } } else if ((MDOL[0].x1==3) && (MDOL[0].y1==4)) // 한가운데 방향 바꾸기  MDOL[0].y1=5; else if ((MDOL[0].x1>6) && (MDOL[0].y1==4)) // 가운데에서 밖으로 빠져나오는 경우 {  MDOL[0].x1 = MDOL[0].x1-6; MDOL[0].y1 = 3; }  m_notice = pae_Str; SetDlgItemText(IDC_NOTICE,m_notice); mode++; if (mode>2) mode = 2; Move(); HfirstDOLx = MDOL[0].x1; HfirstDOLy = MDOL[0].y1; Sleep(500); Pone = FALSE; if ((Move_Count==4) || (Move_Count==5)) { ONEMORE = TRUE; SetDlgItemText(IDC_NOTICE,"한번더!!"); }  if (ONEMORE) { Sleep(500); exit;} if (!ONEMORE) whichturn = COM; if (whichturn==COM) { ComTurn();  if (CONEMORE) { Sleep(500); ComTurn(); CONEMORE=FALSE; } } } GetDlgItem(IDC_GO)->EnableWindow(TRUE); GetDlgItem(IDC_DOL1)->EnableWindow(FALSE); GetDlgItem(IDC_DOL2)->EnableWindow(FALSE); } if (AGAIN) AGAIN = FALSE;}void CKBoardDlg::OnDol2() { // TODO: Add your control notification handler code here    // 두번째돌을 움직이기로 했을때 if (!HSecondDOLIn) { PERSON1or2 = 2; HsecondDOLx = MDOL[0].x2; MDOL[0].x2 = MDOL[0].x2+Move_Count; MDOL[0].num = 2; if (((MDOL[0].x2>5) && (MDOL[0].y2==3)) || ((MDOL[0].x2>6) && (MDOL[0].y2==5))) // 낫으면 {   if ((HDOUBLE) || (HFirstDOLIn)) { WhoWin=1; GAMEAGAIN(); }  HSecondDOLIn = TRUE; DrawDOL(); exit;}  if ((MDOL[0].y2>=0) && (MDOL[0].y2<=3)) {  if (MDOL[0].x2>5)   { MDOL[0].x2 = MDOL[0].x2-5;HsecondDOLy = MDOL[0].y2; MDOL[0].y2++; }  else if (MDOL[0].x2==5) {   switch (MDOL[0].y2) {   case 0 : MDOL[0].x2=0; MDOL[0].y2=4; break; // 첫번째 모자리-방향이 왼쪽대각선쪽으로 바뀜   case 1 : MDOL[0].x2=0; MDOL[0].y2=5; break; // 두번째 모자리-방향이 오른쪽대각선쪽으로 바뀜   }  }  } else if ((MDOL[0].x2==3) && (MDOL[0].y2==4)) // 한가운데 방향 바꾸기    MDOL[0].y2=5;   else if ((MDOL[0].x2>6) && (MDOL[0].y2==4)) // 가운데에서 밖으로 빠져나오는 경우 {  MDOL[0].x2 = MDOL[0].x2-6; MDOL[0].y2 = 3; }   m_notice = pae_Str; SetDlgItemText(IDC_NOTICE,m_notice); mode++; if (mode>2) mode = 2; Move(); HsecondDOLx = MDOL[0].x2; HsecondDOLy = MDOL[0].y2; Sleep(500); Pone = FALSE; if ((Move_Count==4) || (Move_Count==5))  { ONEMORE = TRUE; SetDlgItemText(IDC_NOTICE,"한번더!!"); } if (ONEMORE) { Sleep(500); exit; } if (!ONEMORE) whichturn = COM; if (whichturn==COM) {  ComTurn(); if (CONEMORE) { Sleep(500); ComTurn(); CONEMORE=FALSE; } } GetDlgItem(IDC_GO)->EnableWindow(TRUE); GetDlgItem(IDC_DOL1)->EnableWindow(FALSE); GetDlgItem(IDC_DOL2)->EnableWindow(FALSE);  }}
