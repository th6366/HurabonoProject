/* 
Copyright (C) Information Equipment co.,LTD. 
All rights reserved. 
Code by JaeHyuk Cho <mailto:minzkn@infoeq.com> 
CVSTAG="$Header: /usr/local/mutihost/joinc/modules/moniwiki/data/text/RCS/Code_2fC_2fDecode_5fNSC_5fValue,v 1.1 2007/01/09 02:46:10 root Exp root $" 

filename="test.c" 

  

Simple is best ! 


*/ 

#include <stdio.h>        /* fprintf */ 
#include <string.h>       /* strlen */ 
#include <netinet/in.h>   /* ntohl */ 

int main(int s_argc, char **s_argv) 
{ 
static const unsigned char c_inverse_table[ /* 128 */ ] = { 
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
  0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 
  0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f, 0x20, 0x21, 0x22, 0x23, 0xff, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0x24, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2a, 0x2b, 0x2c, 0x2d, 0x2e, 0x2f, 0x30, 0x31, 0x32, 
  0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3a, 0x3b, 0x3c, 0x3d, 0x3e, 0xff, 0x3f, 0xff, 0xff}; 
if(s_argc > 1) 
{ 
  int s_encode_length = strlen(s_argv[1]), s_decode_length = (-1), s_index; 
  unsigned char s_bit = 0, s_remain_bit, s_byte, s_temp[ 20 ], *s_byte_ptr = (unsigned char *)(&s_temp[0]), s_out[ 8 << 10 ]; 
  for(s_index = 2;s_index < s_encode_length;s_index++) 
  { 
   s_byte = c_inverse_table[(int)s_argv[1][s_index]] & ((unsigned char)0x3f); 
   s_remain_bit = 8 - s_bit; 
   if(s_remain_bit <= 6) 
   { 
    s_bit = 6 - s_remain_bit; 
    *(s_byte_ptr) |= (s_byte >> s_bit); 
    if((s_byte_ptr - ((unsigned char *)(&s_temp[0]))) == 9) 
    { 
     s_decode_length = (int)ntohl(*((unsigned long *)(s_byte_ptr - 4))); 
     if(s_decode_length >= sizeof(s_out)){ s_decode_length = (-1); break; } 
     *(s_out) = *(s_byte_ptr); 
     s_byte_ptr = &s_out[0]; 
    } 
    s_byte_ptr++; 
    *(s_byte_ptr) = s_byte << (8 - s_bit); 
   } 
   else *(s_byte_ptr) = (s_byte << 2), s_bit = 6; 
  } 
  if(s_decode_length > 0) 
  { 
   (void)fprintf(stdout, "Decode string=\"\x1b[1;33m"); 
   for(s_index = 0;s_index < s_decode_length;s_index += 2)(void)fprintf(stdout, "%c", s_out[s_index]); 
   (void)fprintf(stdout, "\x1b[0m\"\n"); 
  } 
  else (void)fprintf(stdout, "Invalid value ! (result=%d)\n", s_decode_length); 
} 
else (void)fprintf(stdout, "usage: %s <nsc value>\n\texample: %s %s\n", s_argv[0], s_argv[0], "02PG000000000KRG1m06K0Pm0q02u0OG1p06O0000"); 
return(0); 
} 

/* End of source */ 
